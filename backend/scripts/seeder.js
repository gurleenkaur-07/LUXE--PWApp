// Seeder script - compatible with server folder format
// Usage: node scripts/seeder.js (import) or node scripts/seeder.js -d (destroy)
const mongoose = require('mongoose');
const Product = require('../models/Product');
const Category = require('../models/Category');
const { products } = require('../data/products');
const { categories } = require('../data/categories');
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const importData = async () => {
  try {
    // Connect to MongoDB
    await mongoose.connect(process.env.MONGODB_URI, {
      dbName: process.env.MONGODB_DB || 'pwa-storefront',
    });
    console.log('MongoDB connected for seeding');

    // Clear old data
    await Product.deleteMany({});
    await Category.deleteMany({});

    // Create categories first
    const categoryMap = {};
    const categoriesToInsert = [];
    
    for (const catData of categories) {
      const category = {
        name: catData.name,
        slug: catData.name.toLowerCase().replace(/\s+/g, '-'),
        isActive: true,
      };
      categoriesToInsert.push(category);
    }
    
    const insertedCategories = await Category.insertMany(categoriesToInsert);
    insertedCategories.forEach(cat => {
      categoryMap[cat.name] = cat._id;
    });

    // Convert and insert products
    const productsToInsert = [];
    for (const productData of products) {
      // Find category ID
      const categoryId = categoryMap[productData.category];
      if (!categoryId) {
        console.warn(`Category "${productData.category}" not found, skipping product: ${productData.name}`);
        continue;
      }

      // Use the already-transformed prices from the data file
      // productData.price is the sale price, productData.originalPrice is the original price
      const salePrice = productData.price;
      const originalPrice = productData.originalPrice;

      // Convert server format to backend format
      const backendProduct = {
        name: productData.name,
        description: productData.description,
        shortDescription: productData.shortDesc,
        price: originalPrice ? parseFloat(originalPrice.toFixed(2)) : parseFloat(salePrice.toFixed(2)),
        discountPrice: originalPrice ? parseFloat(salePrice.toFixed(2)) : null,
        images: [{
          url: productData.imageURL,
          alt: productData.name,
          isPrimary: true,
        }],
        category: categoryId,
        stock: productData.stock || 0,
        isActive: true,
        // SKU will be auto-generated by pre-save hook
      };

      productsToInsert.push(backendProduct);
    }

    await Product.insertMany(productsToInsert);
    console.log(`✅ Data Imported! ${categoriesToInsert.length} categories, ${productsToInsert.length} products`);
    
    // Close mongoose connection before exiting
    await mongoose.connection.close();
    process.exit(0);
  } catch (error) {
    console.error(`❌ Error: ${error.message}`);
    console.error(error.stack);
    // Close mongoose connection even on error
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.close();
    }
    process.exit(1);
  }
};

const destroyData = async () => {
  try {
    // Connect to MongoDB
    await mongoose.connect(process.env.MONGODB_URI, {
      dbName: process.env.MONGODB_DB || 'pwa-storefront',
    });
    console.log('MongoDB connected for seeding');

    await Product.deleteMany({});
    await Category.deleteMany({});

    console.log('❌ Data Destroyed!');
    
    // Close mongoose connection before exiting
    await mongoose.connection.close();
    process.exit(0);
  } catch (error) {
    console.error(`❌ Error: ${error.message}`);
    console.error(error.stack);
    // Close mongoose connection even on error
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.close();
    }
    process.exit(1);
  }
};

// Check if you ran 'node seeder.js -d'
if (process.argv[2] === '-d') {
  destroyData();
} else {
  importData();
}

module.exports = { importData, destroyData };

